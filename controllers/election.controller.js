// jshint esversion:8
require('dotenv').config({ path: __dirname + './../.env' });

//====================================== requiring modules ===========================================//
// node modules
const CryptoJS = require('crypto-js');
const fs = require('fs');
const cloudinary = require('cloudinary').v2;
const secretPhrase = 'hdgfskdgfshgfhsgdfjgsfhgsjhfgjsgjhsgfjhsghjsghfsfgshfgjgfhsgfhsgdhfgsdjfgjsdfhsfhgshjfgsjfgsjfgyu';


// set your env variable CLOUDINARY_URL or set the following configuration
cloudinary.config({
    cloud_name: process.env.CLOUD_NAME,
    api_key: process.env.API_KEY,
    api_secret: process.env.API_SECRET,
  });

// custom models
const user = require('../models/user.model').user;
const election = require('../models/election.model');

let storedPath, path, img1, img2, img3;

//================================== creating HTTP handler methods ==================================//
function processCandidatesData(candidate1, candidate2, candidate3, img1, img2, img3){
    let newStr = '[';
    let jsonStructure = `{"name": "${candidate1}", "vote": "0", "candidateImg": "${img1}"}`;
    let jsonStructure2 = `,{"name": "${candidate2}", "vote": "0", "candidateImg": "${img2}"}`;
    let jsonStructure3 = `,{"name": "${candidate3}", "vote": "0", "candidateImg": "${img3}"}`;

    newStr += jsonStructure;
    newStr += jsonStructure2; 

    if(candidate3 != ""){
        newStr += jsonStructure3;
    }

    newStr += ']';
    return JSON.parse(newStr);
}


// create new election
exports.createElection = (req, res) => {
    // console.log(res.body);
    const image = req.files.electionPoster;
    const candidateOneImg = req.files.candidateOnePic;
    const candidateTwoImg = req.files.candidateTwoPic;
    const candidateThreeImg = req.files.candidateThreePic;
    console.log(process.env.CLOUD_NAME);
    
    
    if(image.name == ""){
        path = __dirname + '/../public/img/gray.jpg';
    }else{
        path = __dirname + '/../public/img/' + image.name;
        img1 = __dirname + '/../public/img/' + candidateOneImg.name;
        img2 = __dirname + '/../public/img/' + candidateTwoImg.name;
        candidateOneImg.mv(img1, () => {});
        candidateTwoImg.mv(img2, () => {});
        if(candidateThreeImg == undefined){
            img3 = __dirname + '/../public/img/gray.jpg';
        }else{
            img3 = __dirname + '/../public/img/' + candidateThreeImg.name;
            candidateThreeImg.mv(img3, () => {});

        }
    }

    console.log(storedPath);
    image.mv(path, () => {
        
        
        // File upload
        cloudinary.uploader.upload(path, { tags: 'basic_sample' }, function (err, image) {
            console.log("** File Upload");
            if (err) { console.warn(err); }
            console.log("* public_id for the uploaded image is generated by Cloudinary's service.");
            console.log("* " + image.url);

            cloudinary.uploader.upload(img1, { tags: 'basic_sample' }, function (err, candidate1) {
                // console.log(`uploader1 code ... ${image.url}`);

                cloudinary.uploader.upload(img2, { tags: 'basic_sample' }, function (err, candidate2) {
                    // console.log(`uploader2 code ... ${candidate2.url}`);

                    cloudinary.uploader.upload(img3, { tags: 'basic_sample' }, function (err, candidate3) {
                        election.create({
                            name: req.body.electionName || null,
                            description:req.body.electionDescription || null,
                            image_url: image.url||null,
                            start_time :req.body.electionStartTime || null,
                            end_time:req.body.electionEndTime || null,
                            candidates: processCandidatesData(req.body.candidateOne, req.body.candidateTwo, req.body.candidateThree, candidate1.url, candidate2.url, candidate3.url) || null
                        }).then(() => {
                            // res.send({msg: `Election creation successful ðŸ˜ŽðŸ˜Ž`});
                            res.redirect('/creatorPage');
                        }).catch((err) => {
                            res.send({err: `${err}`});
                            res.send({msg: `Election creation failed ðŸ˜«ðŸ˜« Candidates`});
                        });
                    });
                    
                });

            });

            
        });

    });            
};

// get current vote results
exports.getElectionResult = (req, res) => {
    election.find({}, (err, electionResults) => {
        if(err){
            res.send({msg: `Can't get election results. Please try again in a minute.`});
        }else{
            res.send({results: electionResults});
        }
    });
};

// get current vote results
exports.getElectionResultById = (req, res) => {
    election.findById(req.query.electionId, (err, election) => {
        if(err){
            res.send({msg: `Can't get election results. Please try again in a minute.`});
        }else{
            res.redirect('/home');
        }
    });
};

// get current vote results
exports.publishElectionById = (req, res) => {
    election.findByIdAndUpdate(req.body.electionId, {"status": "Ended"}, (err, result) => {
        if(err){
            res.send({msg: `Can't get election results. Please try again in a minute.`});
        }else{
            election.findOne({_id: req.body.electionId}, (err, docs) => {
                if(err){
                    res.send({msg: `Unable to decrypt election vote counts.`});
                }else{                    
                    docs.candidates.forEach(element => {                        
                        let bytes = CryptoJS.AES.decrypt(element.voteCount, secretPhrase);
                        let decryptedVoteCount = bytes.toString(CryptoJS.enc.Utf8);
                        element.voteCount = decryptedVoteCount;
                    });

                    docs.save()
                        .then(() => {
                            res.redirect('/home');
                        }).catch(() => {
                            res.send({msg: `Object could not be updated.`});
                        });
                }            
            });
        }
    });
};

// uodate vote results
exports.updateResults = (req, res) => {
    // executes
   election.findOne({_id: req.query._id}, (err, docs) => {
       if(err){
        res.send({msg: `Unable to update, election.`});
       }else{
        //    res.send({candidates: docs["candidates"]});
        docs.candidates.forEach(element => {
            if(req.query.candidateId == element._id){
                let newCountNumber, cipherText;
                if(element.voteCount == "0"){
                    console.log(`Votecount ${element.voteCount}`);
                   let newCountNumber = parseInt(element.voteCount) + 1;
                    console.log(`New Count Number: ${newCountNumber}`);
                    // Encrypt
                cipherText = CryptoJS.AES.encrypt(newCountNumber.toString(), secretPhrase).toString();
                }else{
                    console.log(`Votecount ${element.voteCount}`);

                    let bytes = CryptoJS.AES.decrypt(element.voteCount, secretPhrase);
                    let decryptedVoteCount = bytes.toString(CryptoJS.enc.Utf8);
                    console.log(`decryptedVoteCount ${decryptedVoteCount}`);

                    newCountNumber = parseInt(decryptedVoteCount) + 1;
                    console.log(`New Count Number: ${newCountNumber}`);

                    // Encrypt
                cipherText = CryptoJS.AES.encrypt(newCountNumber.toString(), secretPhrase).toString();
                console.log(`cipherText ${cipherText}`);
                }
                
                element.voteCount = cipherText;
                docs.save()
                    .then(() => {
                        res.send({msg: `Object updated.`});
                    }).catch(() => {
                        res.send({msg: `Object could not be updated.`});
                    });
            }
        });

       }
   });
};

// remove current Election
exports.removeElectionById = (req, res) => {
    election.findByIdAndRemove(req.body.electionId, (err, result) => {
        if(err){
            res.redirect('/homeWithError');
        }else{
            res.redirect('/home');
        }
    });
};

// remove all Elections
exports.removeAllElection = (req, res) => {
    election.deleteMany({})
            .then((docs) => {
                if(docs.ok == 1){
                    res.send({msg: `${docs.deletedCount} election entries deleted.`});
                }else{
                    res.send({msg: `Elections not deleted. Please try again later.`});
                }
                
            }).catch(() => {
                res.send({msg: `Elections not deleted. Please try again later.`});
            });
};

exports.routeToHome = (req, res) => {
    election.find({}, (err, electionResults) => {
        if(err){
            res.send({msg: `Can't get election results. Please try again in a minute.`});
        }else{
            // res.send({results: electionResults});
        res.render(__dirname + './../views/home.views.ejs', {results: electionResults});
}
    });
};